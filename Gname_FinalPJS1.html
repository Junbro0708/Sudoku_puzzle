<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body{
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        td{
            width: 40px;
            height: 40px;
            border: solid 1px;
            border-collapse: collapse;
            text-align: center;
        }
    </style>
</head>
<body>
    <table></table>
    <h2></h2>
</body>
<script>
    let size, values;
    let clickedItem;
    let h2EL = document.querySelector("h2");
    let wrongIdx = new Map();
    let randomColor;

    let tablePop = (values) => {
        const table = document.querySelector("table");
        for(let rowidx in values){
            let tr = document.createElement("tr");
            for(let colIdx in values[rowidx]){
                let td = document.createElement("td");
                // If input number is greater than 9 or less than 0, the background color will be applied.
                if (values[rowidx][colIdx] < 1 || values[rowidx][colIdx] > 9){
                    td.style.backgroundColor = "black";
                    td.style.color = "white"
                }
                td.innerHTML = values[rowidx][colIdx];
                tr.appendChild(td);
            }
            table.appendChild(tr);
        }
    }

    let loadJson = () =>{
        const xmlHTTP = new XMLHttpRequest();
        xmlHTTP.onload = function(){
            let output = JSON.parse(this.responseText)[1]; //You can change the puzzle with an index
            size = output.size;
            values = output.values;
            tablePop(values);
            checkSudoku(size, values);

            randomColor = new Array(size);
            for(let i = 0; i < randomColor.length; i++){
            randomColor[i] = "#" + Math.floor(Math.random()*16777215).toString(16);
            }

            designSudoku(size);
        }
        xmlHTTP.open("GET","./source.json",true);
        xmlHTTP.send();
    }
    loadJson();

    // Check validate Columns
    function checkValColumns(columnIdx, sudokuArray, size){
        let nums = new Map();
        for(let i = 0; i < size; i++){
            if(sudokuArray[columnIdx][i] != 0){
                if(nums.has(sudokuArray[columnIdx][i])){
                    // console.log(sudokuArray[columnIdx][i], nums.get(sudokuArray[columnIdx][i]));
                    wrongIdx.set(`${nums.get(sudokuArray[columnIdx][i]).columnIdx},${nums.get(sudokuArray[columnIdx][i]).i}`, sudokuArray[columnIdx][i]);
                    wrongIdx.set(`${columnIdx},${i}`, sudokuArray[columnIdx][i]);
                    console.log(`${nums.get(sudokuArray[columnIdx][i]).columnIdx},${nums.get(sudokuArray[columnIdx][i]).i}`, sudokuArray[columnIdx][i]);
                    console.log(`${columnIdx},${i}`, sudokuArray[columnIdx][i]);
                    return true;
                }else{
                    nums.set(sudokuArray[columnIdx][i], {columnIdx, i})
                }
            }
        }
        return false;
    }
    
    //Check validate Rows
    function checkValRows(rowIdx, sudokuArray, size){
        let nums = new Map();
        for(let i = 0; i < size; i++){
            if(sudokuArray[i][rowIdx] > 0 && sudokuArray[i][rowIdx] < 10){
                if(nums.has(sudokuArray[i][rowIdx])){
                    // console.log(sudokuArray[i][rowIdx], nums.get(sudokuArray[i][rowIdx]));
                    wrongIdx.set(`${nums.get(sudokuArray[i][rowIdx]).i},${nums.get(sudokuArray[i][rowIdx]).rowIdx}`, sudokuArray[i][rowIdx]);
                    wrongIdx.set(`${i},${rowIdx}`, sudokuArray[i][rowIdx]);
                    console.log(`${nums.get(sudokuArray[i][rowIdx]).i},${nums.get(sudokuArray[i][rowIdx]).rowIdx}`, sudokuArray[i][rowIdx]);
                    console.log(`${i},${rowIdx}`, sudokuArray[i][rowIdx]);
                    return true;
                }else{
                    nums.set(sudokuArray[i][rowIdx], {i, rowIdx});
                }
             } else {
                return true
             }
        }
        return false;
    }

    // Check validate Boxes
    function checkValBoxes(columnIdx, rowIdx, sudokuArray, size){
        boxXIdx = Math.floor(columnIdx / Math.sqrt(size));
        boxYIdx = Math.floor(rowIdx / Math.sqrt(size));
        let nums = new Map();
        for(let i = 0; i < Math.sqrt(size); i++){
            for(let j = 0; j < Math.sqrt(size); j++){
                let x = i + (Math.sqrt(size) * boxXIdx);
                let y = j + (Math.sqrt(size) * boxYIdx);
                if(sudokuArray[x][y] != 0){
                    if(nums.has(sudokuArray[x][y])){
                        // console.log(sudokuArray[x][y], nums.get(sudokuArray[x][y]));
                        wrongIdx.set(`${nums.get(sudokuArray[x][y]).x},${nums.get(sudokuArray[x][y]).y}`, sudokuArray[x][y]);
                        wrongIdx.set(`${x},${y}`, sudokuArray[x][y]);
                        console.log(`${nums.get(sudokuArray[x][y]).x},${nums.get(sudokuArray[x][y]).y}`, sudokuArray[x][y]);
                        console.log(`${x},${y}`, sudokuArray[x][y]);
                        return true;
                    }else{
                        nums.set(sudokuArray[x][y], {x, y});
                    }
                }
            }
        }
        return false;
    }

    // Check All validate (Columns, Rows, Boxes)
    function checkAllValidate(columnIdx, rowIdx, sudokuArray, size){
        if(checkValColumns(columnIdx, sudokuArray, size)){
            return true;
        }
        if(checkValRows(rowIdx, sudokuArray, size)){
            return true;
        }
        if(checkValBoxes(columnIdx, rowIdx, sudokuArray, size)){
            return true;
        }
        return false;
    }

    // Check if the array is right
    function checkSudoku(size, sudokuArray){
        let flag = false;
        for(let i = 0; i < sudokuArray.length; i++){
            for(let j = 0; j < sudokuArray.length; j++){
                if(checkAllValidate(i, j, sudokuArray, size)){
                    h2EL.innerText = "This is wrong sudoku puzzle.";
                    flag = true;
                    // break;
                }
            }
            // if(flag) break;
        }
        console.log(wrongIdx);
        if(!flag) h2EL.innerText = "This is the answer of the puzzle.";
    }

    // design looking like more sudoku
    function designSudoku(size){
        let sudoku = document.querySelector("table").children;
        let tempRow = 1;
        let tempCol = 1;
        for(let i = 0; i < sudoku.length; i++){
            if((tempRow == Math.sqrt(size)) && i != sudoku.length-1){
                for(let j = 0; j < sudoku[i].children.length; j++){
                    sudoku[i].children[j].style.borderBottom = "solid 5px black";
                }
                tempRow = 0;
            }
            for(let j = 0; j < sudoku[i].children.length; j++){
                if((tempCol == Math.sqrt(size)) && j != sudoku.length-1){
                    sudoku[i].children[j].style.borderRight = "solid 5px black";
                    tempCol = 0;
                }
                tempCol++;
            }
            tempCol = 1;
            tempRow++;
        }

        wrongIdx.forEach((val, idx)=>{
            let x = idx.split(",")[0];
            let y = idx.split(",")[1];
            sudoku[x].children[y].style.backgroundColor = randomColor[val-1];
        })
    }

</script>
</html>