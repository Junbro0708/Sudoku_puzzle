<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://code.jquery.com/jquery-3.6.1.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
    <title>Document</title>
    <style>
        body{
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        td{
            width: 40px;
            height: 40px;
            border: solid 1px;
            border-collapse: collapse;
            text-align: center;
        }
        .active{
            background-color: skyblue;
        }
        .not-active{
            background-color: white;
        }
    </style>
</head>
<body>
    <table></table>
    <h2></h2>
</body>
<script>
    let size, values;
    let clickedItem;
    let h2EL = document.querySelector("h2");
    let wrongIdx = new Map();
    let randomColor;

    let tablePop = (values) => {
        const table = document.querySelector("table");
        for(let rowidx in values){
            let tr = document.createElement("tr");
            for(let colIdx in values[rowidx]){
                let td = document.createElement("td");
                td.innerHTML = values[rowidx][colIdx];
                tr.appendChild(td);
            }
            table.appendChild(tr);
        }
    }

    let loadJson = () =>{
        const xmlHTTP = new XMLHttpRequest();
        xmlHTTP.onload = function(){
            let output = JSON.parse(this.responseText)[1]; //You can change the puzzle with an index
            size = output.size;
            values = output.values;
            tablePop(values);
            checkSudoku(size, values);

            validateRowMath(values);
            validateColMath(values);

            randomColor = new Array(size);
            for(let i = 0; i < randomColor.length; i++){
            randomColor[i] = "#" + Math.floor(Math.random()*16777215).toString(16);
            }
            designSudoku(size);
        }
        xmlHTTP.open("GET","./source.json",true);
        xmlHTTP.send();
    }
    loadJson();

    // Check validate Columns
    function checkValColumns(columnIdx, sudokuArray, size){
        let nums = new Map();
        let flag = false;
        for(let i = 0; i < size; i++){
            if(sudokuArray[columnIdx][i] != 0){
                if(nums.has(sudokuArray[columnIdx][i])){
                    wrongIdx.set(`${nums.get(sudokuArray[columnIdx][i]).columnIdx},${nums.get(sudokuArray[columnIdx][i]).i}`, sudokuArray[columnIdx][i]);
                    wrongIdx.set(`${columnIdx},${i}`, sudokuArray[columnIdx][i]);
                    flag = true;
                }else{
                    nums.set(sudokuArray[columnIdx][i], {columnIdx, i})
                }
            }
        }
        if(flag) return true;
        else return false;
    }
    
    //Check validate Rows
    function checkValRows(rowIdx, sudokuArray, size){
        let nums = new Map();
        let flag = false;
        for(let i = 0; i < size; i++){
            if(sudokuArray[i][rowIdx] != 0){
                if(nums.has(sudokuArray[i][rowIdx])){
                    wrongIdx.set(`${nums.get(sudokuArray[i][rowIdx]).i},${nums.get(sudokuArray[i][rowIdx]).rowIdx}`, sudokuArray[i][rowIdx]);
                    wrongIdx.set(`${i},${rowIdx}`, sudokuArray[i][rowIdx]);
                    flag = true;
                }else{
                    nums.set(sudokuArray[i][rowIdx], {i, rowIdx});
                }
            }
        }
        if(flag) return true;
        else return false;
    }

    // Check validate Boxes
    function checkValBoxes(columnIdx, rowIdx, sudokuArray, size){
        boxXIdx = Math.floor(columnIdx / Math.sqrt(size));
        boxYIdx = Math.floor(rowIdx / Math.sqrt(size));
        let nums = new Map();
        let flag = false;
        for(let i = 0; i < Math.sqrt(size); i++){
            for(let j = 0; j < Math.sqrt(size); j++){
                let x = i + (Math.sqrt(size) * boxXIdx);
                let y = j + (Math.sqrt(size) * boxYIdx);
                if(sudokuArray[x][y] != 0){
                    if(nums.has(sudokuArray[x][y])){
                        wrongIdx.set(`${nums.get(sudokuArray[x][y]).x},${nums.get(sudokuArray[x][y]).y}`, sudokuArray[x][y]);
                        wrongIdx.set(`${x},${y}`, sudokuArray[x][y]);
                        flag = true;
                    }else{
                        nums.set(sudokuArray[x][y], {x, y});
                    }
                }
            }
        }
        if(flag) return true;
        else return false;
    }

    // Check All validate (Columns, Rows, Boxes)
    function checkAllValidate(columnIdx, rowIdx, sudokuArray, size){
        let flag = false;
        if(checkValColumns(columnIdx, sudokuArray, size)){
            flag = true;
        }
        if(checkValRows(rowIdx, sudokuArray, size)){
            flag = true;
        }
        if(checkValBoxes(columnIdx, rowIdx, sudokuArray, size)){
            flag = true;
        }
        if(flag) return true;
        else return false;
    }

    // Check if the array is right
    function checkSudoku(size, sudokuArray){
        let flag = false;
        for(let i = 0; i < sudokuArray.length; i++){
            for(let j = 0; j < sudokuArray.length; j++){
                if(checkAllValidate(i, j, sudokuArray, size)){
                    h2EL.innerText = "This is wrong sudoku puzzle.";
                    flag = true;
                }
            }
        }
        console.log(wrongIdx);
        if(!flag) h2EL.innerText = "This is the answer of the puzzle.";
    }

    // design looking like more sudoku
    function designSudoku(size){
        let sudoku = document.querySelector("table").children;
        let tempRow = 1;
        let tempCol = 1;
        for(let i = 0; i < sudoku.length; i++){
            if((tempRow == Math.sqrt(size)) && i != sudoku.length-1){
                for(let j = 0; j < sudoku[i].children.length; j++){
                    sudoku[i].children[j].style.borderBottom = "solid 5px black";
                }
                tempRow = 0;
            }
            for(let j = 0; j < sudoku[i].children.length; j++){
                if((tempCol == Math.sqrt(size)) && j != sudoku.length-1){
                    sudoku[i].children[j].style.borderRight = "solid 5px black";
                    tempCol = 0;
                }
                tempCol++;
            }
            tempCol = 1;
            tempRow++;
        }

        wrongIdx.forEach((val, idx)=>{
            let x = idx.split(",")[0];
            let y = idx.split(",")[1];
            sudoku[x].children[y].style.backgroundColor = randomColor[val-1];
        })
    }

    function validateRowMath(values){
        let checkSet = new Set();
        let sudokuStatus = true;
        for(let iRow = 0; iRow < values.length; iRow++){ //loop in rows
            checkSet.clear() //Clear set when all numbers in row were checked.
            for(let iCol = 0; iCol < values.length; iCol++){ //loop in columns
                if(checkSet.has(values[iRow][iCol])){
                    console.log(`Number ${values[iRow][iCol]} is repeated in row. Position: Row - ${iRow} | Column - ${iCol}`);
                    sudokuStatus = false;
                }else{
                    checkSet.add(values[iRow][iCol]);
                }
            }
        }
        if(sudokuStatus){console.log("No errors in Columns.")};
    }

    function validateColMath(values){
        let checkSet = new Set();
        let sudokuStatus = true;
        for(let iCol = 0; iCol < values.length; iCol++){ //loop in columns
            checkSet.clear() //Clear set when all numbers in column were checked.
            for(let iRow = 0; iRow < values.length; iRow++){ //loop in rows
                if(checkSet.has(values[iRow][iCol])){
                    console.log(`Number ${values[iRow][iCol]} is repeated in column. Position: Row - ${iRow} | Column - ${iCol}`);
                    sudokuStatus = false;
                }else{
                    checkSet.add(values[iRow][iCol]);
                }
            }
        };
        if(sudokuStatus){console.log("No errors in Columns.")};
    }

    $(document).ready(function(){
        let table = $("table");
        $("table").on('click', "td", function(){
            let col = $(this).index();
            let currentRow = $(this).parent().index();
            let allTr = $("table tr");        
            $(allTr.children()).removeClass("active");
            $("table tr").removeClass("active");
            allTr.each(function(idx, elem){ //loop trough all tr and put active class to the td's in the active column
                $($(this).children()[col]).toggleClass("active");
            })
            $(this).parent().toggleClass("active");
        })
    });

</script>
</html>